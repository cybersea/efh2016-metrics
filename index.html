<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8 />
    <title>EFH Metrics</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!--Remote -->
    <!--
    <script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="http://api.tiles.mapbox.com/mapbox.js/plugins/turf/v2.0.0/turf.min.js"></script>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    -->
    <link href='css/normalize.css' rel="stylesheet">
    <!--Local -->
    <script src="js/jquery-1.11.2.min.js"></script>
    <script src="js/leaflet.js"></script>
    <script src="js/turf.min.js"></script>
    <script src="js/jquery.tabletoCSV.js"></script>
    <link rel="stylesheet" href="css/leaflet.css" />
    
    <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Work+Sans:400,500,600' rel='stylesheet' type='text/css'>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: whitesmoke;
            font-family: "Work Sans", Lato, sans-serif;
        }
         
        h1 {
            padding: 8px 25px 8px 15px;
            margin: 0;
            /*
            background: #494f99; 
            background: #709dd6;
            background: #648dc0;
*/
            background: #597DAB;
            color: whitesmoke;
            font-weight: 400;
            font-size: 1.5em;
        }
        
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            width: 64%;
        }
        
/*        LEFT SIDE PANEL*/
        
        #side-panel {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 36%;
            background: whitesmoke;
            border-right: 2px solid #494f99;
            overflow-y: scroll;
        }
       
        
        h2 {
            margin: 0;
            padding: 8px 25px 8px 15px;
            color: #494f99;
            font-weight: 500;
            font-size: 1.2em;
           
        }
        
        h3 {
            padding: 0px 25px 0px 15px;

        }
        
        #side-panel p {
            margin: 8px 0 4px;
            padding: 0 25px 0 15px;
            color: #3d3d3d;
            text-align: right;
            font-size: 1em;
        }
        
        #side-panel p:after {
            content: '';
            display: block;
            clear: both;
        }
        
        
/*        RIGHT SIDE PANEL*/
        
        #right-panel {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 220px;
            background: rgba(240, 240, 240, .6);
            border-left: 2px solid #597DAB;
            z-index: 10;
        }

        
        .info {
            padding: 6px 8px;
            font-size: 1em;
            color: #3d3d3d;
            width: 180px;
        }
        
        .info h3 {
            margin: 0;
            color: #3d3d3d;
        }
        #layer-controls {
            width: 100%;
            border-top: 1px solid #597DAB;
        }
        #layer-controls input {
            display: none;
        }
        #layer-controls label {
            display: block;
            margin: 0 0 1px 0;
            padding: 2px 0 3px 15px;
            background: rgba(255,255,255,1);
            border-bottom: 1px solid #597DAB;
            opacity: .3;
        }
        #layer-controls label:hover {
            background: rgba(255,255,255,.6);
        }
        #layer-controls input:checked + label {
            opacity: 1
        }
        #ui-controls {
            width: 100%;
            margin-top: 25px;
        }
        #ui-controls button {
            background: #597DAB;
            color: white;
            display: block;
            width: 100%;
            margin-bottom: 4px;
            text-align: left;
            padding-left: 15px;
            opacity: .2;
            transition: opacity .25s ease-in-out;
                -moz-transition: opacity .25s ease-in-out;
                -webkit-transition: opacity .25s ease-in-out;
        }
        #ui-controls button.available {
            opacity: 1;
            transition: opacity .25s ease-in-out;
                -moz-transition: opacity .25s ease-in-out;
                -webkit-transition: opacity .25s ease-in-out;
            cursor: pointer;
        }
        table#summary-metrics {
            width: 100%;
            padding: 15px;
            text-align: left; 
        }
        table#summary-metrics tr {
            margin-bottom: 20px;
        }
        #panel-tabs button {
            width: 45%;
            border-radius: 0;
            font-size: 1.3em;
            margin-top: 5px;
            color: #3d3d3d;
        }
        #panel-tabs button:first-child {
            margin-left: 5%;
        }
        #panel-tabs button.selected {
            color: #597DAB;
            border-bottom: ;
        }
        #summary-panel, polygons-panel {
            position: absolute;
            
        }
        #polygons-panel {
            display: none;
        }
        #download-csv {
            position: absolute;
            bottom: 15px;
        }
    </style>
</head>

<body>
        <!-- HTML form for user to select vacancy attribute to map -->
    <!-- Note that values correspond exactly to attribute names in source GeoJSON data file -->

    <div id="right-panel">
        <h2>Available Layers</h2>
        <div id="layer-controls">
            <input id="collabLayer" class="cmn-toggle cmn-toggle-round" type="checkbox" value="collabLayer" checked>
            <label for="collabLayer" style='color:#E5571D'>Collaborative</label>
            <input id="onoLayer" type="checkbox" value="onoLayer" checked>
            <label for="onoLayer" style='color:#6F067B'>Oceana-NRDC-OC</label>
            <input id="fmaLayer" type="checkbox" value="fmaLayer" checked>
            <label for="fmaLayer" id="fmaLayer" style='color:#377EB8'>FMA</label>
            <input id="gfnmsLayer" type="checkbox" value="gfnmsLayer" checked>
            <label for="gfnmsLayer" style='color:#E2007F'>GFNMS</label>
            <input id="greenpeaceLayer" type="checkbox" value="greenpeaceLayer" checked>
            <label for="greenpeaceLayer"style='color:#0F6001'>Greenpeace</label>
            <input id="mciLayer" type="checkbox" value="mciLayer" checked>
            <label for="mciLayer"style='color:#650B0B'>MCI</label>
        </div>
        
        <div id='ui-controls'>
            <button value="Zoom" id="zoom">Zoom to Selection</button>
            <button value="Clear" id="clear">Clear all Selections</button>
        </div>
      
        
    </div><!-- end right-panel -->
    
    <div id='map'></div>

    <!-- Side panel Div   -->
    <div id='side-panel'>
        <h1>West Coast Groundfish<br> Essential Fish Habitat</h1>
        <h2>Alternatives Analysis Metrics</h2>
        <button id='download-csv'>download CSV</button>
        <div id='panel-tabs'>
            <button class='selected' value='summary-panel'>Summary</button>
            <button value = 'polygons-panel'>Polygons</button>
        </div>
        <div id='summary-panel'>
            <h3 id='poly-count'></h3>
            <table id="summary-metrics"></table>
        </div>
        <div id='polygons-panel'>
            <table id ="polygon-metrics" class="data">
            </table>
        </div>
        
    </div>
    

    <!--  GeoJSON source data (var proposals_metrics)   -->
    <script src="data/efh_proposals_metrics.js"></script>

    <!--  Main mapping script   -->
    <script>
        // instantiate the Leaflet map
        var options = {
            center: [41, -124],
            zoom: 6,
            dragging: true,
            zoomControl: true
        }
        var map = L.map('map', options);

        // Base Map
        var esri_ocean = L.tileLayer('http://server.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri',
            maxZoom: 11
        });
        esri_ocean.addTo(map);

        L.control.scale().addTo(map); // Add scale bar

        // Create Info Box for display of feature data on hover
        drawInfo();
        
        // Call function to create user interface for interacting with selected set
        buildUI();
        
        // Create a blank table for summary metrics
        buildSummary();
        
        // Create blank table for individual polygon metrics
        buildPolyTable();

        // Style info for individual proposal layers
        var layerInfo = {
                collabLayer: {
                    proposer: "Collaborative",
                    color: "#E5571D"
                },
                onoLayer: {
                    proposer: "Oceana-NRDC-OC",
                    color: "#6F067B"
                },
                fmaLayer: {
                    proposer: "FMA",
                    color: "#377EB8"
                },
                gfnmsLayer: {
                    proposer: "GFNMS",
                    color: "#E2007F"

                },
                greenpeaceLayer: {
                    proposer: "Greenpeace",
                    color: "#0F6001"
                },
                //                mbnmsLayer: {
                //                    proposer: "MBNMS",
                //                    color: "#E9BD02"
                //                },
                mciLayer: {
                    proposer: "MCI",
                    color: "#650B0B"
                },
            }
            //


        var geoJsonLayers = {}; // global to store all the geoJSON layers
        var selectedSet = []; // array to store selected features

        // Create individual geoJson Layers for each proposal
        for (var lyr in layerInfo) {

            geoJsonLayers[lyr] = L.geoJson(proposals_metrics, {
                filter: function (feature) {
                    if (feature.properties.Proposer == [layerInfo[lyr].proposer]) {
                        return feature;
                    }
                },
                style: function (feature) {
                    var opcty;
                    if (feature.properties.RegAction == "reopen")
                        opcty = 0.1;
                    else if (feature.properties.RegAction == "close")
                        opcty = 0.4;
                    styles = {
                        color: layerInfo[lyr].color,
                        fillColor: layerInfo[lyr].color,
                        fill: true,
                        weight: 2,
                        fillOpacity: opcty
                    }
                    return styles
                },
                onEachFeature: function (feature, layer) {
                    layer.on({
                        mouseover: highlightFeature,
                        mouseout: resetHighlight,
                        click: selected,
                    });
                }
            }).addTo(map);

            geoJsonLayers[lyr].startStyle = styles

        } // end of loop through all geoJSON layers


        // Runs when a feature is selected -- Currently from a single-click
        function selected(e) {

            var layer = e.target;
            var data = layer.feature.properties;
            var id = layer.feature.properties.concat_id;
            var overlapping = [];

            // If it isn't already selected, add to set and change style
            //  otherwise, unselect it
            if (isSelected(layer, id) < 0) {

                // Change Styles 
                layer.setStyle({
                    color: "yellow",
                });
                layer.bringToFront();
                
                // Test if it overlaps any current selections
                for (var i = 0; i < selectedSet.length; i++) {
                    var feat2compare = selectedSet[i]
                    if ( isOverlapped(layer,feat2compare) ) {
                        // if a current feature is overlapped by selection
                        //  add to list 
                        overlapping.push(feat2compare);
                    }
                }
                
                // Add selected feature to the selected set
                selectedSet.push(layer);
                
                // Add the feature's stats to the summary statistics
                updateSummmary();
                
                // Add the feature's metrics to the polygon table
                updatePolyTable(data);
                
                // Unselect any overlapping features
                overlapping.forEach(function(layer) {
                    unselected(layer);
                });
             
            } else { // If already selected
                
                // Unselect it
                unselected(layer);
                
            }
                 
            // Logging for debug
//            console.log("Number of selected Sites: " + selectedSet.length);
//            for (i = 0; i < selectedSet.length; i++) {
//                console.log(selectedSet[i].feature.properties.concat_id)
//            }

        } // end selected()

        // Runs when a feature is removed from selection 
        //  currently passed through from single click
        function unselected(layer) {
           
            // var layer = e.target;
            var data = layer.feature.properties;
            var id = layer.feature.properties.concat_id;
            var proposer = layer.feature.properties.Proposer;

            // If it is selected, remove from selected set array and revert style
            //  otherwise, do nothing
            var idx = isSelected(layer, id)

            if (idx >= 0) {

                // Remove poly from selected set
                selectedSet.splice(idx, 1);

                // Get original color of layer based on proposer
                for (lyr in layerInfo) {
                    if (proposer === layerInfo[lyr].proposer) {
                        var strokeColor = layerInfo[lyr].color
                    }
                }
                
                // Change color back to original 
                layer.setStyle({
                    color: strokeColor,
                });
                layer.bringToFront();
            }

            // Remove the feature's stats from the summary statistics
            updateSummmary();
            
            // Logging for debug
//            console.log("Number of selected Sites: " + selectedSet.length);
//            for (var i = 0; i < selectedSet.length; i++) {
//                console.log(selectedSet[i].feature.properties.concat_id)
//            }

        } // end unselected()

        // Check if a feature is part of the selected set
        function isSelected(layer, id) {
            var idx = -1;
            for (var i = 0; i < selectedSet.length; i++) {
                if (selectedSet[i].feature.properties.concat_id === id) {
                    // Get the array index of the object if it exists
                    idx = i;
                    break;
                }
            }
            return idx
        } // end isSelected()
        
        // Determine if two polygons overlap
        function isOverlapped(feature1, feature2){
            
            // Input is two Leaflet layer polygons 
            // Convert polys GeoJSON
            var poly1 = feature1.toGeoJSON();
            var poly2 = feature2.toGeoJSON();
            
            // Turf Intersection function
            var intersection = turf.intersect(poly1, poly2);
            
            // Only want poly overlaps, not shared boundary intersections
            if (intersection) {
                if (intersection.geometry.type === "Polygon"){
                    return feature2;
                } else {return false}
            } else {return false}
            
        } // end isOverlapped()

        // Create an array of Leaflet Bounds for each feature
        function getSelectedBounds() {

            var selectedBounds = [];

            // Get bounds for selected set of layers
            for (i = 0; i < selectedSet.length; i++) {
                selectedBounds.push(selectedSet[i].getBounds())
            }

            return selectedBounds;
            
        } // end getSelectedBounds()

        function zoomToSelected() {

            // Get the bounds of currently selected features
            var bounds = getSelectedBounds();
            
            // Zooms to currently selected polygons
            map.fitBounds(getSelectedBounds());
            
        } // end zoomToSelected()
        

        // Clear all selected polygons
        function clearSelected() {
            
            for (var i = 0; i < selectedSet.length; i++) {
                
                var layer = selectedSet[i];
                var proposer = layer.feature.properties.Proposer;

                // Get original color of layer based on proposer
                for (lyr in layerInfo) {
                    if (proposer === layerInfo[lyr].proposer) {
                        var strokeColor = layerInfo[lyr].color
                    }
                }
                
                // Change color back to original 
                layer.setStyle({
                    color: strokeColor,
                });
                
                $('#zoom').removeClass('available');
                $('#clear').removeClass('available');
            }
            
            selectedSet = [];  // remove all layers from selected set
            
            buildSummary() // create empty summary table
            
            buildPolyTable() // create empty polygon table
        }

        // Runs on mouseover of a feature - updates style and grabs data for info box
        function highlightFeature(e) {

            var layer = e.target;

            // Change Styles to make outline wider
            layer.setStyle({
                weight: 5,
                dashArray: '',
            });

            if (!L.Browser.ie && !L.Browser.opera) {
                layer.bringToFront();
            }

            // Update the info box               
            updateInfo(layer)

            $(".info").show(); // Show the info box

        } // end highlightFeature()

        // Runs when mouseout of feature - Returns feature style to original
        function resetHighlight(e) {

            // Function that when mouseout of feature
            var layer = e.target;

            layer.setStyle({
                    weight: 2
                })

            $(".info").hide(); // Hide the info box

        } // end resetHighlight()

        function drawInfo() {

            // create a new Leaflet control object, and position it lower right
            var info = L.control({
                position: 'bottomright'
            });
            info.onAdd = function (map) { // when info control is added to map
                    // Create a div to hold the info box with a class name of "info"
                    var div = L.DomUtil.create('div', 'info');
                    // return empty div to be added to map
                    return div;
                }
                // Add empty info div to map
            info.addTo(map);
            $(".info").hide(); // hide empty info box until populated

        } // end drawInfo()


        function updateInfo(layer) {

            // variable to access layer properties
            var data = layer.feature.properties;

            // populate html variable with header - Site name
            // and values for the specified attributes using the 
            // layer (feature) that was passed to this function
            var html = "<h3>" + data.SiteName + "</h3>" // +
            html += "<br>" + "<b>Action: </b>" + data.RegAction;
            html += "<br>" + "<b>Proposer: </b>" + data.Proposer;
            html += "<br>" + "<b>Area (sq mi): </b>" + sqm2sqmi(data.SiteAreaM2);
            html += "<br>" + "<b>Hard Substrate: </b>" + 
                (data.hard / data.SiteAreaM2).toLocaleString(undefined, {style: 'percent'});
            html += "<br>" + "<b>Mixed Substrate: </b>" + 
                (data.mixed / data.SiteAreaM2).toLocaleString(undefined, {style: 'percent'});
            html += "<br>" + "<b>Soft Substrate: </b>" + 
                (data.soft / data.SiteAreaM2).toLocaleString(undefined, {style: 'percent'});
            html += "<br>" + "<b>Unknown Substrate: </b>" + 
                (data.unknown / data.SiteAreaM2).toLocaleString(undefined, {style: 'percent'});

            if (data.CynAreaM2) {
                html += "<br>" + "<b>Canyons and Gullys: </b>" + 
                    (data.CynAreaM2 / data.SiteAreaM2).toLocaleString(undefined, {style: 'percent'});
            } else {
                html += "<br>" + "<b>Canyons and Gullys: </b>  0%";
            }

            if (data.SmtAreaM2) {
                html += "<br>" + "<b>Seamounts: </b>" + 
                    (data.SmtAreaM2 / data.SiteAreaM2).toLocaleString(undefined, {style: 'percent'});
            } else {
                html += "<br>" + "<b>Seamounts: </b> 0%";
            }

            html += "<br>" + "<b>Corals & Sponges</b> (1x1 km blocks): " + data.CntCorSpg;

            if (data.VesCountLB >= 3) {
                html += "<br>" + "<b>Trawl Tow Length (mi): </b>" + m2mi(data.TowLenMLB);
            } else {
                html += "<br>" + "<b>Trawl Tow Length:</b> Unavailable";
            }

            // Assign the html content to the info box using JQuery selector
            $(".info").html(html);

        } // end updateInfo()
        
        function buildUI() {
            // Perform following actions When the DOM object with id of "selPolys" is changed
            // i.e., the user selects an option from the HTML form
            $('#ui-controls button').click(function () {
                // Set attribute to user selection from pull-down menu
                attribute = $(this).val();
                // Re-draw map with new attribute
                if (attribute === "Zoom" && selectedSet.length > 0){
                    zoomToSelected();
                }
                if (attribute === "Clear"){
                    clearSelected();
                }
                
            });
            
             $('#layer-controls input').change(function () {
                 
                 var targetLayer = $(this).val();
                 if(this.checked) {
                     map.addLayer(geoJsonLayers[targetLayer]);
                 } else {
                     map.removeLayer(geoJsonLayers[targetLayer]);
                 }
                 
             });
            
            $('#panel-tabs button').on('click', function() {
                
                 $('#panel-tabs button').toggleClass('selected');
                 $('#summary-panel').toggle();
                 $('#polygons-panel').toggle();
            
            });
            
        }

        // Convert sq meters to square miles and format nicely
        function sqm2sqmi(val) {
            return (val / 2589988.11).toLocaleString(undefined, {
                maximumFractionDigits: 0
            })
        }

        // Convert meters to miles and format nicely
        function m2mi(val) {
            return (val / 1609.344).toLocaleString(undefined, {
                maximumFractionDigits: 0
            })
        }
        
        // Calculate percentage or return zero if denominator is zero
        function pct(num, denom){
            if (denom == 0 || !(num)) {
                return "0%";
            } else {
                return (num / denom).toLocaleString(undefined, {style: 'percent'});
            }         
        }
        
        function buildSummary(){
            
            // Header for Polygon count
            $('#poly-count').text("No Areas Selected")
            
            // shortcut to our table element
            var $table = $('#summary-metrics'),
                rows = '';
            
            // Create empty table structure
            rows += '<tr><th></th>' + '<th>Closed</th>' + '<th>Reopened</th>' + '<th>Net</th></tr>' +
                '<tr><td>Area (sq mi)</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +   
                '<tr><th>Physical Habitat</th>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +  
                '<tr><td>Hard</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Mixed</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Soft</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Unknown</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><th>Priority Habitats</th>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Hard Substrate</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +   
                '<tr><td>Canyons & Gullies</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Seamounts</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Invertebrates (1 km blocks)</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Highest 20% Predicted Spp Occurrence</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td></td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><th>Trawl Activity</th>' + '<th>Displaced</th>' + '<th>Restored</th>' + '<th>Net</th></tr>' +
                '<tr><td>Total Tow Length (mi)</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Catch</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Ex-Vessel Value</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>';

            // update the html of the table
            $table.html(rows);          
    
        }

        function updateSummmary() {
            // use selectedSet to summarize Data
            
            // List of metric attributes
            var metric_attributes = [
                "SiteAreaM2",
                "hard",
                "mixed",
                "soft",
                "unknown",
                "CynAreaM2",
                "SmtAreaM2",
                "CntCorSpg",
                "TowLenMLB",          
            ]
            

            var polyData = []; // individual polygon attributes
            
            // Initialize Summary Data objects with zeros for all metrics
            var summOpen = {
                SiteAreaM2: 0,
                hard: 0,
                mixed: 0,
                soft: 0,
                unknown: 0,
                CynAreaM2: 0,
                SmtAreaM2: 0,
                CntCorSpg: 0,
                TowLenMLB: 0      
            };
            var summClose = {
                SiteAreaM2: 0,
                hard: 0,
                mixed: 0,
                soft: 0,
                unknown: 0,
                CynAreaM2: 0,
                SmtAreaM2: 0,
                CntCorSpg: 0,
                TowLenMLB: 0      
            };
            
            // loop through all the selected features
            selectedSet.forEach(function(selection) {
                
                var props = selection.feature.properties;
                
                // Add individual polygon metrics to polyData list
                polyData.push(props);
                                
                // loop through the properties
                for(var att in props) {
                    
                    // Only use metrics of interest
                    if (metric_attributes.indexOf(att) >= 0){
                    // if it's a number
                        if(Number(props[att])) {
                            
                            // Areas to be closed
                            if (props.RegAction === "close"){
                                summClose[att] += props[att];
                            } else { // areas to be reopened
                                summOpen[att] += props[att];
                            }

                        }
                    }
                }
                
            });  // end of forEach loop through selectedSet            
            
            // create Net value object
            summNet = calcNet(summClose, summOpen);
            
            // Update area count text
            var polyCount = selectedSet.length;
           
            if(polyCount == 0) {
                $('#zoom').removeClass('available');
                $('#clear').removeClass('available');
            } else {

                 $('#zoom').addClass('available');
                 $('#clear').addClass('available');
            }
            
            
            if (polyCount == 1){
                $('#poly-count').text(polyCount + " Area Selected")
            } else{
                $('#poly-count').text(polyCount + " Areas Selected")    
            }
                        
            // shortcut to our table element
            var $table = $('#summary-metrics'),
                rows = '';
            
            // Variables for frequently used metrics
            var areaClose = summClose.SiteAreaM2;
            var areaOpen = summOpen.SiteAreaM2;
            var areaNet = areaClose - areaOpen;
            
            // Populate the table
            rows += '<tr><th></th>' + '<th>Closed</th>' + '<th>Reopened</th>' + '<th>Net</th></tr>' +
                '<tr><td>Area (sq mi)</td>' + '<td>' + sqm2sqmi(areaClose) + '</td>' + 
                    '<td>' + sqm2sqmi(areaOpen) + '</td>' + 
                    '<td>' + sqm2sqmi(areaNet) + '</td></tr>' +   
                '<tr><th>Physical Habitat</th><td></td><td></td><td></td></tr>' +  
                '<tr><td>Hard</td>' + '<td>' + pct(summClose.hard, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.hard, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.hard, summOpen.hard), areaNet) + '</td></tr>' +
                '<tr><td>Mixed</td>'+ '<td>' + pct(summClose.mixed, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.mixed, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.mixed, summOpen.mixed), areaNet) + '</td></tr>' +
                '<tr><td>Soft</td>' + '<td>' + pct(summClose.soft, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.soft, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.soft, summOpen.soft), areaNet) + '</td></tr>' +
                '<tr><td>Unknown</td>'  + '<td>' + pct(summClose.unknown, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.unknown, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.unknown, summOpen.unknown), areaNet) + '</td></tr>' +
                '<tr><th>Priority Habitats</th><td></td><td></td><td></td></tr>' +
                '<tr><td>Hard Substrate</td>' + '<td>' + pct(summClose.hard, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.hard, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.hard, summOpen.hard), areaNet) + '</td></tr>' +
                '<tr><td>Canyons & Gullies</td>' + '<td>' + pct(summClose.CynAreaM2, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.CynAreaM2, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.CynAreaM2, summOpen.CynAreaM2), areaNet) + '</td></tr>' +
                '<tr><td>Seamounts</td>' + '<td>' + pct(summClose.SmtAreaM2, areaClose) + '</td>' + 
                    '<td>' + pct(summOpen.SmtAreaM2, areaOpen) + '</td>' + 
                    '<td>' + pct(calcNet(summClose.SmtAreaM2, summOpen.SmtAreaM2), areaNet) + '</td></tr>' +
                '<tr><td>Invertebrates (1 km blocks)</td>'  + '<td>' + summClose.CntCorSpg + '</td>' + 
                    '<td>' + summOpen.CntCorSpg + '</td>' + 
                    '<td>' + calcNet(summClose.CntCorSpg, summOpen.CntCorSpg) + '</td></tr>' +
                '<tr><td>Highest 20% Predicted Spp Occurrence</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td></td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><th>Trawl Activity</th><th>Displaced</th><th>Restored</th><th>Net</th></tr>' +
                '<tr><td>Total Tow Length (mi)</td>'  + '<td>' + m2mi(summClose.TowLenMLB) + '</td>' + 
                    '<td>' + m2mi(summOpen.TowLenMLB) + '</td>' + 
                    '<td>' + m2mi(calcNet(summClose.TowLenMLB, summOpen.TowLenMLB)) + '</td></tr>' +
                '<tr><td>Catch</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>' +
                '<tr><td>Ex-Vessel Value</td>' + '<td></td>' + '<td></td>' + '<td></td></tr>';
            
            // update the html of the table
            $table.html(rows);
            
            // update individual poly table with the selected set
            updatePolyTable();

            
        } // end updatedSummary()
        
        function calcNet(close, open){
            
            // Calculate Net value from summary data values
            // Most values are just difference, but some, like Coral/Sponge block count will need additional logic
            return close - open;
                  
        } // end calcNet
        
        function buildPolyTable(){
            // shortcut to our table element
            var $table = $('#polygon-metrics'),
                rows = '';

            // empty table structure
            rows += '<tr>' + 
                '<th colspan="3">Site</th>' + 
                '<th></th>' + 
                '<th colspan="4">Physical Habitat </th>' +
                '<th colspan="4">Priority Habitats</th>' +
                '<th>Trawl Activity</th>' +            
                '</tr>'
            rows += '<tr>' + 
                '<th>Action</th>' + 
                '<th>Name</th>' + 
                '<th>Proposer</th>' + 
                '<th>Area (sq mi)</th>' +
                '<th>Hard</th>' +
                '<th>Mixed</th>' +
                '<th>Soft</th>' +
                '<th>Unknown</th>' +
                '<th>Canyons and Gullies</th>' +
                '<th>Seamounts</th>' +
                '<th>Corals & Sponges (1 km blocks)</th>' +
                '<th>Highest 20% Predicted Spp</th>' +
                '<th>Trawl Tow Length (mi)</th>' +            
                '</tr>'

            // update the html of the table
            $table.html(rows);          
    
        }
        
        function updatePolyTable(){
            // Build content of Poly Table with selectedSet
            
            var $table = $('#polygon-metrics'),
                rows = '';

            // Table Headers
            rows += '<tr>' + 
                '<th colspan="3">Site</th>' + 
                '<th></th>' + 
                '<th colspan="4">Physical Habitat </th>' +
                '<th colspan="4">Priority Habitats</th>' +
                '<th>Trawl Activity</th>' +            
                '</tr>'
            rows += '<tr>' + 
                '<th>Action</th>' + 
                '<th>Name</th>' + 
                '<th>Proposer</th>' + 
                '<th>Area (sq mi)</th>' +
                '<th>Hard</th>' +
                '<th>Mixed</th>' +
                '<th>Soft</th>' +
                '<th>Unknown</th>' +
                '<th>Canyons and Gullies</th>' +
                '<th>Seamounts</th>' +
                '<th>Corals & Sponges (1 km blocks)</th>' +
                '<th>Highest 20% Predicted Spp</th>' +
                '<th>Trawl Tow Length (mi)</th>' +            
                '</tr>'
            
            // loop through all the selected features
            selectedSet.forEach(function(selection) {
                
                var data = selection.feature.properties;
                
                // Tow Length filter (< 3 vessels in an area)
                var towLen;
                if (data.VesCountLB >= 3) {
                    towLen = m2mi(data.TowLenMLB);
                } else {
                    towLen = "unavailable";
                }
                
                            
                rows += '<tr>' + 
                    '<td>' + data.RegAction + '</td>' + 
                    '<td>' + data.SiteName + '</td>' + 
                    '<td>' + data.Proposer + '</td>' + 
                    '<td>' + sqm2sqmi(data.SiteAreaM2) + '</td>' +
                    '<td>' + pct(data.hard, data.SiteAreaM2) + '</td>' +
                    '<td>' + pct(data.mixed, data.SiteAreaM2) + '</td>' +
                    '<td>' + pct(data.soft, data.SiteAreaM2) + '</td>' +
                    '<td>' + pct(data.unknown, data.SiteAreaM2) + '</td>' +
                    '<td>' + pct(data.CynAreaM2, data.SiteAreaM2) + '</td>' +
                    '<td>' + pct(data.SmtAreaM2, data.SiteAreaM2) + '</td>' +
                    '<td>' + data.CntCorSpg + '</td>' +
                    '<td> X% </td>' +
                    '<td>' + towLen + '</td>' +            
                    '</tr>'              
                });

          
            // update the html of the table
            $table.html(rows);  
         
        } // end of updatePolyTable()
        
        (function () {
            
            $("#download-csv").click(function(){
2               
                console.log('hi');
                $('#polygon-metrics').tableToCSV();
3
            });

        })();
        
    </script>

</body>

</html>